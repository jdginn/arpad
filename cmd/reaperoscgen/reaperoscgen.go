package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
)

// OSC pattern type prefixes
const (
	TypeNormalized = "n/"
	TypeFloat      = "f/"
	TypeInteger    = "i/"
	TypeString     = "s/"
	TypeBoolean    = "b/"
	TypeTrigger    = "t/"
	TypeRotary     = "r/"
)

// OSCPattern represents a single OSC pattern with its type prefix and path elements
type OSCPattern struct {
	TypePrefix  string
	Path        []string
	FullPath    string
	GoType      string
	HasWildcard bool
}

// Action represents a REAPER action with its associated OSC patterns
type Action struct {
	Name          string
	Patterns      []*OSCPattern
	Documentation string
}

// Generator holds the state for code generation
type Generator struct {
	pkg        string
	actions    map[string]*Action
	outputFile string
}

// NewGenerator creates a new Generator instance
func NewGenerator(pkg string) *Generator {
	return &Generator{
		pkg:     pkg,
		actions: make(map[string]*Action),
	}
}

// parsePattern parses an OSC pattern into its components
func parsePattern(pattern string) (*OSCPattern, error) {
	if len(pattern) == 0 {
		return nil, fmt.Errorf("empty pattern")
	}

	// Extract type prefix
	var typePrefix string
	for _, prefix := range []string{TypeNormalized, TypeFloat, TypeInteger, TypeString, TypeBoolean, TypeTrigger, TypeRotary} {
		if strings.HasPrefix(pattern, prefix) {
			typePrefix = prefix
			pattern = strings.TrimPrefix(pattern, prefix)
			break
		}
	}

	if typePrefix == "" {
		return nil, fmt.Errorf("invalid type prefix in pattern: %s", pattern)
	}

	// Split path into elements
	elements := strings.Split(pattern, "/")
	// Remove empty elements
	var path []string
	for _, elem := range elements {
		if elem != "" {
			path = append(path, elem)
		}
	}

	// Add this check:
	if len(path) == 0 {
		return nil, fmt.Errorf("no path elements in pattern")
	}

	// Determine Go type based on type prefix
	goType := ""
	switch typePrefix {
	case TypeNormalized, TypeFloat:
		goType = "float64"
	case TypeInteger:
		goType = "int64"
	case TypeString:
		goType = "string"
	case TypeBoolean:
		goType = "bool"
	case TypeTrigger:
		goType = "bool"
	case TypeRotary:
		goType = "float64"
	}

	hasWildcard := false
	for _, elem := range path {
		if elem == "@" {
			hasWildcard = true
			break
		}
	}

	return &OSCPattern{
		TypePrefix:  typePrefix,
		Path:        path,
		FullPath:    pattern,
		GoType:      goType,
		HasWildcard: hasWildcard,
	}, nil
}

// Parse reads and parses the OSC config file
func (g *Generator) Parse(configPath string) error {
	file, err := os.Open(configPath)
	if err != nil {
		return fmt.Errorf("failed to open config file: %w", err)
	}
	defer file.Close()

	var currentDoc strings.Builder
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines
		if line == "" {
			continue
		}

		// Handle comments
		if strings.HasPrefix(line, "#") || strings.HasPrefix(line, "//") {
			currentDoc.WriteString(strings.TrimPrefix(strings.TrimPrefix(line, "#"), "//"))
			currentDoc.WriteString("\n")
			continue
		}

		// Parse action line
		fields := strings.Fields(line)
		if len(fields) < 2 {
			continue
		}

		actionName := fields[0]
		patterns := fields[1:]

		// Create or get existing action
		action, exists := g.actions[actionName]
		if !exists {
			action = &Action{
				Name:          actionName,
				Patterns:      make([]*OSCPattern, 0),
				Documentation: currentDoc.String(),
			}
			g.actions[actionName] = action
		}

		// Parse patterns
		for _, pattern := range patterns {
			osc, err := parsePattern(pattern)
			if err != nil {
				log.Printf("Warning: skipping invalid pattern '%s': %v", pattern, err)
				continue
			}
			action.Patterns = append(action.Patterns, osc)
		}

		// Reset documentation buffer for next action
		currentDoc.Reset()
	}

	return scanner.Err()
}

// filterPatterns applies pattern filtering rules
func (g *Generator) filterPatterns() {
	for _, action := range g.actions {
		filtered := make([]*OSCPattern, 0)
		seen := make(map[string]bool)

		// Sort patterns by number of elements (longest first)
		for _, pattern := range action.Patterns {
			key := strings.Join(pattern.Path, "/")
			if !seen[key] {
				filtered = append(filtered, pattern)
				seen[key] = true
			}
		}

		action.Patterns = filtered
	}
}

// generateCode generates the Go source code
func (g *Generator) generateCode() ([]byte, error) {
	var buf bytes.Buffer

	// 	// Write package declaration and imports
	// 	tmpl := template.Must(template.New("header").Parse(`// Code generated by reaperoscgen; DO NOT EDIT.
	//
	// package {{.Package}}
	//
	// import (
	// 	"fmt"
	// 	"errors"
	// 	"github.com/yourusername/deviceapi"
	// )
	//
	// var ErrOutOfRange = errors.New("parameter out of valid range")
	//
	// // Reaper provides a type-safe interface to REAPER's OSC API
	// type Reaper struct {
	// 	*deviceapi.OscDevice
	// 	{{range .Actions}}
	// 	{{if .HasRoot}}{{.Name}} *{{.TypeName}}{{end}}
	// 	{{end}}
	// }
	// `))

	data := struct {
		Package string
		Actions []*Action
	}{
		Package: g.pkg,
		Actions: make([]*Action, 0, len(g.actions)),
	}

	for _, action := range g.actions {
		data.Actions = append(data.Actions, action)
	}

	// if err := tmpl.Execute(&buf, data); err != nil {
	// 	return nil, err
	// }

	// Generate type definitions and methods for each action
	for _, action := range g.actions {
		if err := g.generateActionCode(&buf, action); err != nil {
			return nil, err
		}
	}

	return buf.Bytes(), nil
}

func main() {
	var (
		configPath string
		outputPath string
		pkgName    string
	)

	flag.StringVar(&configPath, "config", "", "Path to REAPER OSC config file")
	flag.StringVar(&outputPath, "output", "reaper_device_gen.go", "Output file path")
	flag.StringVar(&pkgName, "package", "reaper", "Package name for generated code")
	flag.Parse()

	if configPath == "" {
		log.Fatal("Config file path is required")
	}

	gen := NewGenerator(pkgName)
	if err := gen.Parse(configPath); err != nil {
		log.Fatalf("Failed to parse config: %v", err)
	}

	gen.filterPatterns()

	code, err := gen.generateCode()
	if err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	if err := os.WriteFile(outputPath, code, 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}
}
