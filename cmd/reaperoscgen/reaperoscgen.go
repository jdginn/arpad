package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
)

// Generator holds the state for code generation
type Generator struct {
	pkg        string
	outputFile string
}

// NewGenerator creates a new Generator instance
func NewGenerator(pkg string) *Generator {
	return &Generator{
		pkg: pkg,
	}
}

func (g *Generator) generatePreamble(buf *bytes.Buffer) {
	fmt.Fprintf(buf, "// Code generated by reaperoscgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "package %s\n\n", g.pkg)
	fmt.Fprintf(buf, "import (\n")
	fmt.Fprintf(buf, "    \"fmt\"\n")
	fmt.Fprintf(buf, "\n")
	fmt.Fprintf(buf, "    \"github.com/jdginn/arpad/devices\"\n")
	fmt.Fprintf(buf, ")\n\n")
}

func main() {
	var (
		configPath string
		outputPath string
		pkgName    string
	)

	flag.StringVar(&configPath, "config", "", "Path to REAPER OSC config file")
	flag.StringVar(&outputPath, "output", "reaper_device_gen.go", "Output file path")
	flag.StringVar(&pkgName, "package", "reaper", "Package name for generated code")
	flag.Parse()

	if configPath == "" {
		log.Fatal("Config file path is required")
	}

	generator := NewGenerator(pkgName)

	file, err := os.Open(configPath)
	if err != nil {
		log.Fatalf("failed to open config file: %v", err)
	}
	defer file.Close()

	parsedActions, err := Parse(file)
	if err != nil {
		log.Fatalf("Failed to parse config: %v", err)
	}

	tree := BuildTree(parsedActions)

	var code bytes.Buffer
	generator.generatePreamble(&code)
	GenerateAllStructs(tree, &code)

	formatted, err := format.Source(code.Bytes())
	if err != nil {
		if err := os.WriteFile(outputPath, code.Bytes(), 0644); err != nil {
			log.Fatalf("Failed to write output file: %v", err)
		}
		log.Fatalf("Failed to format generated code: %v", err)
	}
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}
}
