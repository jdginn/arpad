package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
)

// Generator holds the state for code generation
type Generator struct {
	pkg        string
	actions    map[string]*Action
	outputFile string
}

// NewGenerator creates a new Generator instance
func NewGenerator(pkg string) *Generator {
	return &Generator{
		pkg:     pkg,
		actions: make(map[string]*Action),
	}
}

// filterPatterns applies pattern filtering rules
func (g *Generator) filterPatterns() {
	for _, action := range g.actions {
		filtered := make([]*OSCPattern, 0)
		seen := make(map[string]bool)

		// Sort patterns by number of elements (longest first)
		for _, pattern := range action.Patterns {
			key := strings.Join(pattern.Path, "/")
			if !seen[key] {
				filtered = append(filtered, pattern)
				seen[key] = true
			}
		}

		action.Patterns = filtered
	}
}

// generateCode generates the Go source code
func (g *Generator) generateCode() ([]byte, error) {
	var buf bytes.Buffer

	// 	// Write package declaration and imports
	// 	tmpl := template.Must(template.New("header").Parse(`// Code generated by reaperoscgen; DO NOT EDIT.
	//
	// package {{.Package}}
	//
	// import (
	// 	"fmt"
	// 	"errors"
	// 	"github.com/yourusername/deviceapi"
	// )
	//
	// var ErrOutOfRange = errors.New("parameter out of valid range")
	//
	// // Reaper provides a type-safe interface to REAPER's OSC API
	// type Reaper struct {
	// 	*deviceapi.OscDevice
	// 	{{range .Actions}}
	// 	{{if .HasRoot}}{{.Name}} *{{.TypeName}}{{end}}
	// 	{{end}}
	// }
	// `))

	data := struct {
		Package string
		Actions []*Action
	}{
		Package: g.pkg,
		Actions: make([]*Action, 0, len(g.actions)),
	}

	for _, action := range g.actions {
		data.Actions = append(data.Actions, action)
	}

	// if err := tmpl.Execute(&buf, data); err != nil {
	// 	return nil, err
	// }

	// Generate type definitions and methods for each action
	for _, action := range g.actions {
		if err := g.generateActionCode(&buf, action); err != nil {
			return nil, err
		}
	}

	return buf.Bytes(), nil
}

func main() {
	var (
		configPath string
		outputPath string
		pkgName    string
	)

	flag.StringVar(&configPath, "config", "", "Path to REAPER OSC config file")
	flag.StringVar(&outputPath, "output", "reaper_device_gen.go", "Output file path")
	flag.StringVar(&pkgName, "package", "reaper", "Package name for generated code")
	flag.Parse()

	if configPath == "" {
		log.Fatal("Config file path is required")
	}

	file, err := os.Open(configPath)
	if err != nil {
		log.Fatalf("failed to open config file: %v", err)
	}
	defer file.Close()

	parsedActions, err := Parse(file)
	if err != nil {
		log.Fatalf("Failed to parse config: %v", err)
	}

	tree := BuildTree(parsedActions)
	fmt.Print(printHierarchy(tree))

	// var code []byte
	//
	// if err := os.WriteFile(outputPath, code, 0644); err != nil {
	// 	log.Fatalf("Failed to write output file: %v", err)
	// }
}
